#!/bin/bash

# locate non-relative script dir
MAIN_SCRIPT_BASEDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# normalize path to script
MAIN_SCRIPT="${MAIN_SCRIPT_BASEDIR}/"$( basename $0 )
EXECUTION_DIR=$(dirname ${MAIN_SCRIPT})

# locate .startup directory
SUB_COMPONENTS_DIRNAME=$( dirname $MAIN_SCRIPT_BASEDIR )"/.startup"
SELF_COMPONENTS_DIRNAME=$( dirname $MAIN_SCRIPT)"/.startup"

MAIN_SCRIPT_DIRNAME=$(dirname $MAIN_SCRIPT)

if [ "${MAIN_SCRIPT_DIRNAME}" = ".startup" ]
then export COMPONENTS_DIRNAME="${MAIN_SCRIPT_DIRNAME}"
else export COMPONENTS_DIRNAME="${MAIN_SCRIPT_DIRNAME}/.startup"
fi


if [ ! -d "${COMPONENTS_DIRNAME}" ]
then
 printf "component scripts directory '${COMPONENTS_DIRNAME}' does not exist.\n"
 exit 2
fi

# get list of components

COMPONENT_SCRIPTS=$(cd $COMPONENTS_DIRNAME; ls)

ORDER_FILE="${COMPONENTS_DIRNAME}/startup.order"
# check for order file
if [ -f "${ORDER_FILE}" ]
then
 export COMPONENT_ORDER=$(cat ${ORDER_FILE})
 # verify every file listed in components exists in executable script form in the .startup directory
 for component_name in $COMPONENT_ORDER
 do
  if [ ! -f "${component_name}" ]
  then
   printf "component startup script '${component_name}' is missing.\n";
  fi
  if [ ! -x "${component_name}" ]
  then
   printf "component startup script '${component_name}' is not executable.\n";
  fi
 done

 # verify no additional files unlisted in startup.order
 difference=$(comm <(echo "${COMPONENT_ORDER}" | sort) <(echo "${COMPONENT_SCRIPTS}"))
 printf "Difference: $difference\n"
else
 printf "# component order is based on filenames. Consider adding a startup.order file to control order of startup.\n"
 export COMPONENT_ORDER="$COMPONENT_SCRIPTS"
fi

if [ -z "${COMPONENT_ORDER}" ]
then
 printf "There are no component scripts in ${COMPONENTS_DIRNAME}\n";
 exit 2
fi

# if no components selected, show options and help
if [ -z "$*" ]
then
 printf "You must select from the following available components:\n%s\n" "${COMPONENT_ORDER}"
 exit 0
fi

# if all is selected, change arguments to match as if they were listed out individually
if [ "$1" = "all" ]
then TO_RUN="${COMPONENT_ORDER}"
else TO_RUN="$*"
fi

to_run_ary=()
while read -r line; do to_run_ary+=("$line"); done <<< "${TO_RUN}"
order_ary=()
while read -r line; do order_ary+=("$line"); done <<< "${COMPONENT_ORDER}"

printf "to_run: %s\n" "${to_run_ary[@]}"

# execute components in order
containsElement () {
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}

for selected in "${to_run_ary[@]}"
do
 if containsElement "${selected}" "${order_ary[@]}"
 then
  FULL_SCRIPT_PATH="${COMPONENTS_DIRNAME}/${selected}"
  printf "executing: %s\n" "${FULL_SCRIPT_PATH}"
  ( cd ${EXECUTIOND_DIR} && bash ${FULL_SCRIPT_PATH})
  last_status=$?
  if [[ last_status -ne 0 ]]
  then
   printf "script %s failed with status: %s\n" "${FULL_SCRIPT_PATH}" "${last_status}"
  fi
 fi
done

